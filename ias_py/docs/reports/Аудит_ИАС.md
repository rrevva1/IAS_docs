### Технический и архитектурный аудит проекта IAS (Yii2 Help Desk / Asset Management)

**Дата**: 2026-02-05  
**Контекст**: монолит Yii2 (MVC), БД PostgreSQL (есть дамп), фронт с AG Grid.  
**Приоритеты эксплуатации**: надежность, поддерживаемость, предсказуемость, минимальные операционные риски.

---

### 1️⃣ Анализ текущей реализации (по факту)

#### 1.1. Фактическая архитектура
- **Монолитный Yii2 MVC**, близко к `yii2-app-basic`:
  - контроллеры содержат CRUD + бизнес-операции + JSON-эндпоинты + экспорт.
  - ActiveRecord одновременно «сущность + доступ к данным + часть бизнес-логики».
  - Search-модели содержат не только фильтры, но и правила видимости данных.
- **Отсутствует выделенный слой application/domain**:
  - нет сервисов (use-cases), репозиториев/портов, DTO/response-моделей.
  - инфраструктура (файлы, отправка файлов) тесно связана с HTTP-контекстом.

#### 1.2. Ключевые модули и ответственность по папкам
- **Конфигурация/компоненты**: `config/web.php`, `config/db.php`.
- **Контроллеры**: `controllers/TasksController.php`, `controllers/UsersController.php`, `controllers/ArmController.php`, `controllers/SiteController.php`, `controllers/HelpDeskController.php`.
- **Доменные сущности (AR)**: `models/entities/Users.php`, `Tasks.php`, `DeskAttachments.php`, `Arm.php`, `Location.php`.
- **Search-модели**: `models/search/TasksSearch.php`, `UsersSearch.php`, `ArmSearch.php`.
- **Вложения**: хранение файлов в `/web/uploads/tasks/`, метаданные в `desk_attachments`, связь с задачей хранится как JSON в `tasks.attachments` (на текущем коде).

#### 1.3. Где сосредоточена бизнес-логика
- **Контроллеры**:
  - `TasksController` включает создание/обновление задач, удаление вложений, скачивание/preview вложений, изменение статуса/исполнителя по AJAX, отдачу данных для AG Grid, статистику, экспорт в Excel.
  - `UsersController` включает CRUD пользователей + «тестовые/служебные» экшены.
- **ActiveRecord-модели**:
  - `Tasks` реализует сохранение/загрузку файлов и ведёт массив вложений, конвертируя в JSON в `beforeSave()`.
  - `Users` реализует роль/права и проверку пароля (в текущем виде — небезопасно).
- **Search-модели**:
  - `TasksSearch` и `UsersSearch` фактически решают «кто что видит» (админ vs пользователь).

#### 1.4. Связность (coupling)
- **Высокая связность контроллер ↔ AR ↔ файловая система ↔ HTTP**:
  - контроллеры собирают ответы JSON, запускают `save(false)`, дергают файловые операции через модели.
- **Смешение авторизации с бизнес-логикой**:
  - часть действий ограничена только фактом авторизации (`roles => ['@']`), а не правами.
- **Сильная зависимость от схемы БД, при этом схема не едина между миграциями/дампом/кодом** (см. раздел 2.5).

#### 1.5. Технический долг (верхний уровень)
- ИБ: MD5, утечки секретов/паролей в логах/интерфейсах, «тестовые» экшены.
- Архитектура: нет сервисного слоя, бизнес-логика размазана.
- Данные: несогласованность схемы, хранение вложений как JSON в `tasks`, слабая целостность.
- Производительность: отдача «всех задач» в AG Grid без пагинации, N+1 в статистике.
- Тесты: устаревшие и не соответствуют текущим моделям/формам.

---

### 2️⃣ Слабые места и риски (с примерами из репозитория)

#### 2.1. Критические риски ИБ: пароли, секреты, отладка

**2.1.1. Пароли хранятся/проверяются через MD5**
- `models/entities/Users.php`: `setPassword()` делает `md5()`.
- `models/forms/LoginForm.php`: пароль сравнивается как `md5($this->password)` с `user->password`, а также логируется введенный пароль.

**Почему критично**
- MD5 не подходит для паролей (быстро брутится, легко атакуется по радужным таблицам).
- Логи с паролями — прямой комплаенс/инцидент.

**2.1.2. Секреты/креды в репозитории**
- `config/web.php`: фиксированный `cookieValidationKey`.
- `config/db.php`: пароль БД (`12345`) хранится в коде.

**2.1.3. «Тестовые»/опасные экшены в рабочем контроллере**
- `controllers/UsersController.php`: присутствуют экшены вида `actionResetPassword()` (фиксированный пароль), `actionTestPasswords()` (вывод хешей), `actionIndex2()` (показывает поле `password`).

#### 2.2. Авторизация и роли: непредсказуемость
- В `Users` роль определяется **двумя несовместимыми способами**:
  - по **магическим ID** (`isAdmin()`/`isUser()`),
  - по **строке `role_name`** (`isAdministrator()`).
- Это порождает риск, что часть проверок не сработает при изменении справочника ролей/данных.

#### 2.3. Контроль доступа в задачах недостаточно строгий
- `controllers/TasksController.php` в `behaviors()` разрешает все действия любому авторизованному (`roles => ['@']`), без разделения админ/пользователь по операциям.

Риск: операции административного уровня (назначение исполнителя, изменение статуса, скачивание вложений) могут стать доступны не тем ролям.

#### 2.4. Вложения/файлы: риск утечек и нарушения целостности
- Вложения выбираются по `attach_id` и отправляются через `sendFile`.
- При этом в текущем подходе есть риск отсутствия проверки:
  - что вложение принадлежит задаче,
  - что пользователь имеет право видеть задачу/вложение.

Дополнительный риск: `inline` отдача `svg` (если разрешено) может открыть XSS-вектор.

#### 2.5. Самый опасный риск: дрейф схемы БД (код ↔ миграции ↔ дамп)

**Факт из дампа** `ias_uch_vnii_public_dump.sql`:
- Таблица `public.tasks` содержит колонку `user_id`, а не `id_user`.
- Таблица `public.users` содержит `id_user`, `full_name`, `id_role` и дополнительные поля (position, department, phone).
- Таблица `public.roles` использует `id_role` как PK.

**Факт из миграций**:
- `m251022_193201_create_users_table.php` / `m251022_193211_create_users_table.php` создают таблицу `users` с полями `id`, `fio`, `role_id` (то есть совсем другая схема).
- `m251022_193200_create_roles_table.php` / `m251022_193222_create_roles_table.php` создают `roles` с полями `id`, `role_name` (не совпадает с дампом `id_role`).
- `m251023_104000_create_tasks_table.php` создаёт `tasks.user_id`, но код в `Tasks`/`TasksController` использует `id_user`.

**Почему это критично для предприятия**
- Нельзя гарантировать повторяемость окружений: dev/test/prod будут расходиться.
- Миграции могут «сломать» боевую БД или привести к полупримененным состояниям.
- Деплой/восстановление из бэкапа становится рискованным.

#### 2.6. Производительность/масштабирование
- `TasksController::actionGetGridData()` отключает пагинацию и формирует JSON для всех задач.
- В статистике есть признаки N+1 (агрегаты + `Users::findOne()` в цикле).

#### 2.7. Поддержка и bus factor
- Документация описывает безопасность оптимистично, но код содержит явные нарушения (MD5, пароли в логах, тестовые экшены).
- Тесты (`tests/unit/models/LoginFormTest.php`) не соответствуют актуальным полям формы (используют `username` вместо `email`), что снижает ценность тестового покрытия.

---

### 3️⃣ Улучшения без смены стека (Yii2/PHP): пошагово, без «переписать всё»

#### Этап 0 (1–3 дня): «стабилизация и стоп-кровотечение»
- **Пароли**:
  - перевести на `Yii::$app->security->generatePasswordHash()` и `validatePassword()`;
  - убрать MD5 полностью (или оставить только краткий совместимый период с прозрачным апгрейдом при логине).
- **Убрать утечки**:
  - удалить/закрыть тестовые экшены (`testPasswords`, `index2`, `resetPassword` с фикс. паролем);
  - убрать логирование введенного пароля и хешей.
- **Секреты и конфиги**:
  - вынести `cookieValidationKey` и креды БД в env (dotenv/переменные окружения, secret storage).
- **Доступы**:
  - ограничить административные actions в `TasksController` по роли (минимум `AccessControl` + `matchCallback` на администратора).
- **Файлы**:
  - запретить/ограничить inline предпросмотр для опасных типов (минимум `svg`), добавить `X-Content-Type-Options: nosniff`.

#### Этап 1 (1–2 недели): привести роли/ACL к единой модели
- **Единый источник прав**:
  - либо Yii2 RBAC (`authManager` + permissions),
  - либо строгий «Roles enum + policies» без магических чисел.
- Ввести **policy-методы** (минимально):
  - `TaskPolicy::canView($user, $task)`
  - `TaskPolicy::canChangeStatus($user, $task)`
  - `AttachmentPolicy::canDownload($user, $attachment, $task)`

#### Этап 2 (2–4 недели): сервисный слой + транзакции
- Ввести `services/`:
  - `TaskService` (создание/смена статуса/назначение исполнителя/комментарии),
  - `AttachmentService` (upload/delete/send).
- Ввести DTO для AG Grid (исключить сбор массивов в контроллере).
- Объединить «создание задачи + загрузка файлов» в **транзакцию**:
  - либо всё успешно, либо откат (и удаление файлов при ошибке БД).

#### Этап 3 (2–6 недель): нормализовать модель вложений
- Убрать `tasks.attachments` как JSON-список ID и сделать нормальную связь:
  - `task_attachments(task_id, attach_id)` + FK + индексы.
- Для выдачи файла:
  - проверять права на задачу,
  - проверять принадлежность вложения задаче,
  - MIME определять через `finfo`, а не только расширение.

#### Этап 4 (параллельно): наблюдаемость и тестируемость
- Логи: категории `security`, `audit`, `tasks`, `attachments`, без чувствительных данных.
- Мониторинг: Sentry/ELK/Graylog; базовые метрики.
- Тесты: минимальный «safety net»:
  - логин,
  - доступ к чужим задачам/вложениям (запрет),
  - загрузка/удаление вложений,
  - смена статуса/назначение исполнителя (права).

---

### 4️⃣ Альтернативные технологические стеки (enterprise-оценка)

| Вариант | Плюсы для enterprise | Минусы/риски | Требования к команде | Зрелость экосистемы | Насколько подходит под Help Desk / Asset |
|---|---|---|---|---|---|
| **Django + PostgreSQL** | зрелый фреймворк, сильный admin, безопасность по умолчанию, скорость разработки | может стать «жирным монолитом» без архитектурной дисциплины | Python + Django опыт | очень зрелая | отлично для CRUD/справочников/аудита |
| **FastAPI + SQLAlchemy** | быстрый API-first, async, OpenAPI | «конструктор»: RBAC/админка/фоновые задачи надо проектировать | Python + опыт архитектуры API | зрелая | отлично для API/интеграций, UI отдельно |
| **ASP.NET Core + PostgreSQL** | enterprise-лига: DI, auth, observability, интеграции с AD/LDAP | выше порог входа, требования к кадрам | .NET команда | очень зрелая, LTS | лучший вариант в AD/Windows окружениях |
| **Go (Gin/Fiber) + PostgreSQL** | производительность, простота деплоя | много инфраструктуры «руками», меньше готовых enterprise компонентов | Go + DDD/арх опыт | зрелая | хорошо для высоконагруженных API/интеграций |
| **NestJS (Node.js) + PostgreSQL** | DI/архитектурные паттерны, рынок разработчиков | управление зависимостями, дисциплина безопасности | TypeScript/Nest | зрелая | хорош при сильной TS-команде |

---

### 5️⃣ Архитектура при смене стека (без микросервисного фанатизма)

**Рекомендация по форме**: **модульный монолит** (bounded contexts внутри одного деплоя), потому что:
- общий домен (пользователи/роли/справочники/файлы),
- микросервисы резко увеличат операционные риски (консистентность, трассировка, DevOps, SLA).

#### Слои
- **UI/API слой**: Web UI + REST (или API-first).
- **Application layer**: use-cases (CreateTask, AssignExecutor, UploadAttachment, ChangeStatus).
- **Domain layer**: доменные правила, политики доступа, события.
- **Infrastructure layer**: ORM/репозитории, файловое хранилище, интеграции, почта.

#### Файлы
- Минимум: FS + метаданные в БД + строгий ACL.
- Лучше: S3/MinIO + AV-сканирование + временные ссылки.

#### Аутентификация/роли
- В идеале: OIDC/SAML (Keycloak/Azure AD) + RBAC/ABAC.
- Локальные пароли — только как fallback, строго bcrypt/argon2.

---

### 6️⃣ Оценка миграции (сложность, reuse, риски, трудоёмкость)

| Вариант | Сложность миграции | Что можно переиспользовать | Основные риски | Оценка, чел‑мес |
|---|---|---|---|---|
| **Остаться на Yii2 и «оздоровить»** | Low–Medium | всё (код, БД, UI) | нужно вычистить ИБ-дыры и привести схему/миграции к истине | 2–4 |
| **Django** | Medium | БД (после нормализации), доменные сценарии | перенос UI/AG Grid, перенос auth/ACL, переосмысление файлов | 6–10 |
| **FastAPI** | Medium–High | БД, API-контракты | админка/RBAC/фоновые задачи «собрать», риск “зоопарка” | 7–12 |
| **ASP.NET Core** | Medium | БД, enterprise-подход | кадровые риски/обучение, перенос UI | 8–14 |
| **Go** | High | БД, доменные правила | много инфраструктуры руками | 9–16 |
| **NestJS** | Medium–High | БД, API-first подход | долгоживущая поддержка зависимостей и безопасность | 7–12 |

---

### Итоговая рекомендация и оптимальный путь развития

#### Что я бы выбрал на месте архитектора предприятия
1) **Сразу**: не менять стек, а привести текущий Yii2 к безопасному и предсказуемому состоянию (ИБ + схема + ACL).  
2) **Далее**: перейти к **модульному монолиту внутри Yii2** (сервисный слой, политики доступа, нормализация вложений, транзакции, наблюдаемость, тестовый минимум).  
3) **После стабилизации данных и доменных сценариев**: оценивать ре-платформинг на **ASP.NET Core** (если предприятие AD/Windows‑центричное) или **Django** (если сильная Python‑команда).

#### Почему именно так
- Сейчас главные риски — **не платформа**, а **ИБ + дрейф схемы + слабый ACL + утечки**.  
- Миграция на новый стек, не вылечив доменную модель/данные, перенесёт хаос в новую технологию и увеличит риски.

---

### Приложение: обнаруженные несоответствия/заметки
- В документации упоминается `UserTasksController`, но в `controllers/` файла нет (нужно проверить историю/ветки или удалить/актуализировать документацию).
- Миграции содержат дублирующиеся версии создания ролей/пользователей/задач (требуется нормализация миграционной истории и baseline под прод).

